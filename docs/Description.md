# تحلیل و تصمیمات فنی

هدف این پروژه پیاده‌سازی یک سرویس ساده برای **رزرو غذا با ربات تلگرام** بوده. سعی کردم تمرکز اصلی روی درک درست مسئله، تمیز بودن کد و تصمیم‌گیری‌های فنی آگاهانه باشه، نه صرفاً زیاد کردن امکانات.

---

## طراحی کلی سیستم

پروژه به‌صورت کلی به سه بخش تقسیم شده:

* **لایه ربات تلگرام**
  مسئول گرفتن پیام‌ها و Callbackها از تلگرام و تبدیل تعامل کاربر به درخواست‌های سمت سرور. برای سادگی و با توجه به ابعاد پروژه و محدودیت زمانی، پردازش پیام‌ها به‌صورت **synchronous** انجام شده است.

* **لایه سرویس (Business Logic)**
  جایی که منطق اصلی مثل گرفتن لیست غذاها، ثبت سفارش و قوانین ساده سیستم انجام می‌شه.

* **لایه دیتابیس**
  با استفاده از JPA / Hibernate اطلاعات غذا، کاربر و سفارش ذخیره می‌شن.

همچنین برای افزایش امنیت و تمیزی طراحی، **لایه دیتابیس از DTOها جدا شده** و از Entityها مستقیماً در API یا Bot استفاده نشده است. این کار باعث می‌شود وابستگی به دیتابیس کمتر شود و تغییرات آینده راحت‌تر انجام شوند.

---

## ارتباط با Telegram Bot API

برای ارتباط با تلگرام از **Polling (getUpdates)** استفاده شده چون:

* راه‌اندازی ساده‌تری داره
* برای اجرا در محیط لوکال و تست خیلی مناسب‌تره
* برای مقیاس این پروژه کاملاً جواب می‌ده

تعامل کاربر به این شکله:

* با `/start` یا `/menu` منوی غذاها نمایش داده می‌شه
* انتخاب غذا با دکمه‌های Inline انجام می‌شه
* شناسه تلگرام کاربر به‌عنوان شناسه کاربر سیستم در نظر گرفته شده

---

## مدل داده‌ها

مدل داده‌ها عمداً ساده طراحی شده‌اند تا تمرکز روی اصل مسئله باشه:

* **Food**: اطلاعات غذا (نام، قیمت، وضعیت فعال بودن)
* **User**: فقط Telegram User ID
* **Order**: ارتباط بین کاربر و غذا به‌همراه زمان ثبت

هر سفارش به یک کاربر و یک غذا متصله و هر کاربر می‌تونه چند سفارش داشته باشه.
این ساختار به‌راحتی قابل توسعه‌ست (مثلاً تعداد، وضعیت سفارش و…).

---

## بخش ادمین و APIها

برای بخش ادمین:

* APIهای CRUD غذا پیاده‌سازی شده
* API دریافت لیست سفارش‌ها با امکان فیلتر (کاربر، بازه زمانی) وجود داره
* مستندات API از طریق **Swagger** در دسترسه و تصویرش در README قرار داده شده
* یک Postman Collection هم برای تست APIها اضافه شده

برای احراز هویت، از **Basic Auth** استفاده شده.

---

## پیام‌ها و چندزبانه بودن

برای مدیریت متن پیام‌ها، از **MessageSource** و فایل‌های `messages_fa.properties` استفاده شده است.
این کار باعث می‌شه:

* متن پیام‌ها از کد جدا باشن
* تغییر یا اصلاح پیام‌ها بدون تغییر کد انجام بشه
* در صورت نیاز، اضافه کردن زبان جدید ساده‌تر باشه

---

## مدیریت خطا و حالت‌های خاص

* اگر غذایی موجود نباشه، پیام مناسب به کاربر نمایش داده می‌شه
* خطاهای دیتابیس به‌شکل کنترل‌شده مدیریت شده‌اند

---

## تصمیمات و ساده‌سازی‌ها (Trade-off)

* از Webhook استفاده نشده چون برای هدف پروژه ضروری نبود
* فرآیند سفارش ساده نگه داشته شده (بدون تأیید نهایی یا وضعیت‌های مختلف)
* پردازش‌ها به‌صورت synchronous انجام شده که برای پروژه‌ای با این ابعاد و محدودیت زمانی مناسب بوده
* تست خودکار نوشته نشده به‌دلیل محدودیت زمان، ولی ساختار کد برای اضافه شدن تست مناسبه

---

## اگر زمان بیشتری داشتم

اگه زمان بیشتری داشتم:

* اضافه کردن وضعیت سفارش (ثبت‌شده، لغو‌شده و…)
* جلوگیری از ثبت سفارش تکراری
* نوشتن تست‌های Integration برای APIها
* استفاده از Docker برای اجرای راحت‌تر
* پیاده‌سازی احراز هویت قوی‌تر برای ادمین

---

## جمع‌بندی

تلاش کردم توی این پروژه:

* مسئله رو درست تحلیل کنم
* کد تمیز و قابل فهم بنویسم
* لایه‌ها رو تا حد ممکن از هم جدا نگه دارم
* حداقل‌ها رو با کیفیت پیاده‌سازی کنم
* تصمیمات فنی رو آگاهانه بگیرم، حتی جاهایی که عمداً ساده نگه داشته شده

